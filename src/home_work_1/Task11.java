package home_work_1;

import java.util.Scanner;

public class Task11 {
    public static void main(String[] args) {
        Scanner console = new Scanner(System.in);

        System.out.println("Введите первое число.");
        int number1 = console.nextInt();

        System.out.println("Введите второе число.");
        int number2 = console.nextInt();

        // Во всех заданиях дальше я оставляю комментарии в классах,
        // чтобы вначале полнее для самой себя же раскрыть, что я делаю (плюс где-то требуются комментарии,
        // например, во втором задании).

        // Результирующий бит, полученный в результате выполнения оператора OR, |,
        // равен 1, если соответствующий бит в любом из операндов равен 1.

        // Значение бита, полученное в результате выполнения побитового оператора AND, &,
        // равно 1, если соответствующие биты в операндах также равны 1.
        // Во всех остальных случаях значение результирующего бита равно 0.

        int andNumber = number1 & number2;
        System.out.println(andNumber);
        // Например, 1 число - 8, его 2-ный код = 00001000.
        //          2 число - 10, его 2-ный код = 00001010;
        // Результат побитовой операции для них = 00001000. Только в 1 случае биты совпадали так, что равнялись
        // 1 (5 бит), поэтому только там рез. бит = 1, в остальных случаях рез. биты равны 0.
        // В десятичной системе число 00001000 равно 8. Программа выдает это же значение.

        int orNumber = number1 | number2;
        System.out.println(orNumber);
        // Например, 1 число - 8, его 2-ный код = 00001000.
        //          2 число - 10, его 2-ный код = 00001010;
        // Результат побитовой операции для них = 00001010. Только в 2 случаях один из битов равнялся 1 (5 и 7),
        // поэтому только там рез. бит = 1, в остальных случаях рез. биты равны 0.
        // В десятичной системе число 00001010 равно 10. Программа выдает это же значение.

        double number425 = 42.5;

        // double result425 = number425 & 2;
        // Код выдаст ошибку программы. Побитовые операторы могут быть применимы
        // только к целочисленными типам переменных (double таким не является). Как понимаю, это потому что
        // у целочисленных типов есть точное двоичное представление
        // (а вещественные/дробные типы не имеют точного двоичного представления из-за промежуточных округлений).
        // В двоичную систему дробные числа переводятся по
        // следующему алгоритму: вначале переводится целая часть десятичной дроби в двоичную систему счисления;
        // затем дробная часть десятичной дроби умножается на основание двоичной системы счисления;
        // в полученном произведении выделяется целая часть, которая принимается в качестве значения первого
        // после запятой разряда числа в двоичной системе счисления; алгоритм завершается, если дробная
        // часть полученного произведения равна нулю или если достигнута требуемая точность вычислений.
        // В противном случае вычисления продолжаются с предыдущего шага. Таким образом, побитовое сравнение
        // в данном случае невозможно, так как по ходу перевода double в 2-ную систему происходят промежуточные
        // округления, таким образом, двоичное представление точное только в определенной степени.
    }
}
