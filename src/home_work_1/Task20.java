package home_work_1;

public class Task20 {
    public static void main(String[] args) {
        int a = 8;
        int b = 2;
        int c = 5;

        boolean z = true;
        boolean x = false;

        int result21 = c + b / a;
        // 5 + 2 / 8 равно 5. Вначале выполняем оператор деления, потом сложения.
        // Так как переменные c и b целочисленные, то, так как 2 меньше 8,
        // результат их деления равен 0. 5 + 0 = 5.
        System.out.println("Результат примера 2.1: 5 + 2 / 8 = " + result21);

        int result22 = (c + b) / a;
        // (5 + 2) / 8 равно 0. Вначале выполняем действия в скобках, потом оператор деления.
        // Так как переменные целочисленные, то, так как сумма 5 и 2 меньше 8,
        // результат их деления равен 0, то есть 7 / 8 = 0.
        System.out.println("Результат примера 2.2: (5 + 2) / 8 = " + result22);

        int result23 = (c + b++) / a;
        // (5 + 2++) / 8 равно 0. Вначале выполняем оператор инкремента, потом действия в скобках, потом
        // оператор деления. Так как переменные целочисленные, то, так как сумма 5 и 2 меньше 8, результат
        // их деления равен 0. Так как оператор ++ стоит после переменной (является постфиксным),
        // то переменную увеличилась бы на 1 после выполнения действия
        // (то есть переменная в этом ходе остается неизменной).
        System.out.println("Результат примера 2.3: (5 + 2++) / 8 = " + result23);

        // я заново переназначаю исходные значения, так как по условию задачи переменные должны
        // во всех примерах равняться исходным значениям, то есть, например, b++ не станет в следующем
        // примере 2+1 (хотя должна была бы). Так же будет с другим переменными.

        a = 8;
        b = 2;
        c = 5;

        int result24 = (c + b++) / --a;
        // (5 + 2++) / --8 равно 1. Вначале выполняем операторы инкремента и декремента, потом действия
        // в скобках (сложение), потом оператор деления. Переменная b в этом ходе останется неизменной,
        // переменная a станет меньше на 1 в этом ходе (так как ее декремент префиксный).
        // Переменная b стала бы больше на 1 после этого хода (если бы не условие задачи),
        // так как используется постфиксный инкремент.
        // Таким образом (5+2) / 7 = 1.
        System.out.println("Результат примера 2.4: (5 + 2++) / --8 = " + result24);

        a = 8;
        b = 2;
        c = 5;

        int result25 = (c * b >> b++) / --a;
        // (5 * 2 >> 2++) / --8 равно 0. Вначале выполняем операторы инкремента и декремента, потом действия
        // в скобках (вначале умножение, потом сдвиг вправо с дополнением знака), потом оператор деления.
        // Переменная b в этом ходе останется неизменной,
        // переменная a станет меньше на 1 в этом ходе (так как ее декремент префиксный, то есть 8-1=7).
        // Переменная b стала бы больше на 1 после этого хода (если бы не условие задачи),
        // так как используется постфиксный инкремент. c*b = 10. 10 в двоичной системе = 1010. Сдвигаем
        // 2 бита (значение неизменной b) справа. Получаем "10". Переводим ее в десятичную систему - получаем
        // 2. 2/7 = 0 (так как сумма 2 меньше 7, то результат их деления равен 0).
        System.out.println("Результат примера 2.5: (5 * 2 >> 2++) / --8 = " + result25);

        a = 8;
        b = 2;
        c = 5;
        int d = 7;
        int e = 20;
        int f = 68;
        int g = 22;

        int result26 = (c + d > e ? f : g * b >> b++) / --a;
        // (5 + 7 > 20 ? 68 : 22 * 2 >> 2++) / --8 равно 1. Вначале выполняем операторы инкремента и декремента,
        // потом действия в скобках (вначале умножение 22 на 2, потом сложение 5 и 7,
        // потом сдвиг вправо с дополнением знака), потом оператор "больше чем", потом условный оператор (?:).
        // Переменная b в этом ходе останется неизменной, переменная a станет меньше на 1 в этом ходе
        // (так как ее декремент префиксный, то есть 8-1=7). Переменная b стала бы больше на 1 после этого
        // хода (если бы не условие задачи), так как используется постфиксный инкремент.
        // g*b = 44. 44 в двоичной системе = 101100. Сдвигаем 2 бита (значение неизменной b) справа.
        // Получаем "1011". Переводим ее в десятичную систему - получаем 11. Выражение принимает вид
        // 12 > 20 ? 68 : 11. 12 не больше 20, значит false. В таком выражении, если левая часть равна false,
        // то все выражение в скобках принимает значение равное правой части после ":", то есть 11. 11/7 = 1
        // (Так как переменные целочисленные, то, так как 11 не делится без остатка на 7, результат их
        // деления равен первому числу, которое меньше их суммы и делится без остатка на 7).
        // Таким числом является 7. 7 / 7 = 1.
        System.out.println("Результат примера 2.6: (5 + 7 > 20 ? 68 : 22 * 2 >> 2++) / --8 = " + result26);

        a = 8;
        b = 2;

        // int result27 = (c + d > e ? f >= f : g * b >> b++) / --a;
        // (5 + 7 > 20 ? 68 >= 68 : 22 * 2 >> 2++) / --8 выдаст ошибку программы. Очередность по большей
        // части совпадает с предыдущим примером, только перед условным оператором необходимо было выполнить
        // оператор >=. В данном случае программа не сработает, так как запись оператора >= приводит
        // к выражению 68 >= 68 равному true, а в данной части выражение требуется численное значение, не
        // boolean.

        b = 2;
        int h = 119;
        int i = 12;
        int j = 3;
        int k = 6;

        boolean result28 = k - b > j && i * i <= h;
        // 6 - 2 > 3 && 12 * 12 <= 119 равно false. Вначале выполняем действия вычитания и умножения в левой
        // и правой части выражения (независимо друг от друга). Потом выполняем действия сравнения в левой
        // и правой части (независимо друг от друга). И потом выполняет оператор && (выражение будет равно
        // true только если оба выражения из правой и левой части будут равны true. Если один false,
        // выражение равно false. 6 - 2 = 4. 12 * 12 = 144. 4 больше 3, значит 6 - 2 > 3 = true. 144 больше
        // 119, значит 12 * 12 <= 119 = false. Значит, все выражение - false.
        System.out.println("Результат примера 2.8: 6 - 2 > 3 && 12 * 12 <= 119 = " + result28);

        boolean result29 = z && x;
        // true && false - такое выражение с boolean переменными будет равно true только если оба операнда
        // будут равны true. Если один false, то все выражение равно false. Значит, здесь false.
        System.out.println("Результат примера 2.9: true && false = " + result29);
    }
}
